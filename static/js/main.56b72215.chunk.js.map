{"version":3,"sources":["components/App/App.types.ts","components/App/App.const.ts","components/App/App.helpers.ts","components/App/App.tsx","components/App/App.hooks.ts","serviceWorker.ts","index.tsx"],"names":["EWebRTCTypes","EClientTypes","EServerTypes","ICE_SERVERS","urls","username","credential","videoElement","a","stream","navigator","mediaDevices","getUserMedia","audio","video","srcObject","Promise","resolve","reject","peerConnectionHandlers","peerConnection","createPeerConnection","isMediaStream","getTracks","forEach","track","addTrack","socket","sdp","desc","RTCSessionDescription","setRemoteDescription","createAnswer","answer","setLocalDescription","send","JSON","stringify","type","VIDEO_ANSWER","payload","localDescription","undefined","sendToWSS","json","RTCPeerConnection","iceServers","Object","assign","App","useState","isCameraOn","setIsCameraOn","isReady","setIsReady","isConnected","setIsConnected","info","setInfo","videoRef","useRef","receivedVideoRef","socketRef","peerConnectionRef","useEffect","turnCameraOn","current","then","catch","onnegotiationneeded","useCallback","createOffer","offer","VIDEO_OFFER","onicecandidate","event","candidate","NEW_ICE_CANDIDATE","ontrack","streams","CONNECTED","useMemo","onMessage","parsedData","parse","data","console","log","INFO","users","readyUsers","connectedUsers","CALL","initRTC","pc","HANG_UP","handleVideoOfferMsg","handleVideoAnswerMsg","candidateInit","RTCIceCandidate","addIceCandidate","error","handleNewICECandidateMsg","socketHandlers","WebSocket","onmessage","useSocket","handleReadyClick","NOT_READY","READY","handleNextClick","NOT_CONNECTED","className","muted","autoPlay","playsInline","ref","onClick","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","registration","unregister","message"],"mappings":"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","file":"static/js/main.56b72215.chunk.js","sourcesContent":["export enum EWebRTCTypes {\n  NEW_ICE_CANDIDATE = '[webrtc]: new_ice_candidate',\n  VIDEO_OFFER = '[webrtc]: video_offer',\n  VIDEO_ANSWER = '[webrtc]: video_answer',\n}\n\nexport enum EClientTypes {\n  READY = '[client]: ready',\n  NOT_READY = '[client]: not_ready',\n  CONNECTED = '[client]: connected',\n  NOT_CONNECTED = '[client]: not_connected',\n}\n\nexport enum EServerTypes {\n  INFO = '[server]: info',\n  CALL = '[server]: call',\n  HANG_UP = '[server]: hang_up',\n}\n\nexport interface ISendData<T = any> {\n  type: EWebRTCTypes | EClientTypes | EServerTypes;\n  payload?: T;\n}\n\nexport interface ISocketHandlers {\n  onMessage: (event: MessageEvent) => void;\n}\n\nexport interface IPeerConnectionHandlers {\n  onnegotiationneeded: () => void;\n  onicecandidate: (event: RTCPeerConnectionIceEvent) => void;\n  ontrack: (event: RTCTrackEvent) => void;\n}","export const ICE_SERVERS = [\n  {\n    urls: 'stun:stun.i.google.com:19302',\n  },\n  {\n    urls: 'turn:194.87.239.193:3478?transport=udp',\n    username: 'evstarostin',\n    credential: 'jck30011989',\n  },\n  {\n    urls: 'turn:194.87.239.193:3478?transport=tcp',\n    username: 'evstarostin',\n    credential: 'jck30011989',\n  },\n]\n\nexport const WEB_SOCKET_SERVER = process.env.NODE_ENV === 'development' ? 'ws://localhost:7000' : 'wss://evstar.ru:7000';","import { ICE_SERVERS } from \"./App.const\";\nimport { EWebRTCTypes, IPeerConnectionHandlers, ISendData } from \"./App.types\";\n\nexport async function turnCameraOn(videoElement: HTMLVideoElement) {\n  let stream = null;\n\n  try {\n    stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });\n    videoElement.srcObject = stream;\n    return Promise.resolve();\n  } catch(error) {\n    return Promise.reject(error);\n  }\n}\n\nexport async function initRTC(\n  videoElement: HTMLVideoElement,\n  peerConnectionHandlers: IPeerConnectionHandlers,\n) {\n  const { srcObject } = videoElement;\n  const peerConnection = createPeerConnection(peerConnectionHandlers);\n\n  if (!isMediaStream(srcObject)) return;\n\n  try {\n    await srcObject.getTracks().forEach(track => peerConnection.addTrack(track, srcObject));\n    return Promise.resolve(peerConnection);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n}\n\nexport function handleNewICECandidateMsg(candidateInit: RTCIceCandidateInit, peerConnection: RTCPeerConnection) {\n  const candidate = new RTCIceCandidate(candidateInit);\n\n  try {\n    peerConnection.addIceCandidate(candidate);\n  } catch (error) {}\n}\n\nexport async function handleVideoOfferMsg(\n  videoElement: HTMLVideoElement,\n  socket: WebSocket,\n  sdp: RTCSessionDescriptionInit,\n  peerConnectionHandlers: IPeerConnectionHandlers,\n) {\n  const { srcObject } = videoElement;\n  if (!isMediaStream(srcObject)) return;\n  \n  try {\n    const peerConnection = createPeerConnection(peerConnectionHandlers);\n    const desc = new RTCSessionDescription(sdp);\n    await peerConnection.setRemoteDescription(desc);\n    srcObject.getTracks().forEach(track => peerConnection.addTrack(track, srcObject));\n    const answer = await peerConnection.createAnswer();\n    await peerConnection.setLocalDescription(answer);\n    socket.send(JSON.stringify({ type: EWebRTCTypes.VIDEO_ANSWER, payload: peerConnection.localDescription }));\n    return Promise.resolve(peerConnection);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n}\n\nexport function handleVideoAnswerMsg(peerConnection: RTCPeerConnection, sdp: RTCSessionDescriptionInit) {\n  const desc = new RTCSessionDescription(sdp);\n\n  peerConnection.setRemoteDescription(desc);\n}\n\nexport function isMediaStream(srcObject: MediaStream | MediaSource | Blob | null): srcObject is MediaStream {\n  return (srcObject as MediaStream).getTracks !== undefined;\n}\n\nexport function sendToWSS(socket: WebSocket | null, json: ISendData) {\n  socket?.send(JSON.stringify(json));\n}\n\nfunction createPeerConnection(peerConnectionHandlers: IPeerConnectionHandlers) {\n  const peerConnection = new RTCPeerConnection({ iceServers: ICE_SERVERS });\n\n  Object.assign(peerConnection, peerConnectionHandlers);\n  return peerConnection;\n}","import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport {\n  handleNewICECandidateMsg,\n  handleVideoAnswerMsg,\n  handleVideoOfferMsg,\n  initRTC,\n  turnCameraOn,\n  sendToWSS,\n} from './App.helpers';\nimport { useSocket } from './App.hooks';\nimport { EClientTypes, EServerTypes, EWebRTCTypes, ISendData } from './App.types';\nimport './App.scss';\n\nfunction App() {\n  const [isCameraOn, setIsCameraOn] = useState(false);\n  const [isReady, setIsReady] = useState(false);\n  const [isConnected, setIsConnected] = useState(false);\n  const [info, setInfo] = useState('');\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const receivedVideoRef = useRef<HTMLVideoElement>(null);\n  const socketRef = useRef<WebSocket | null>(null);\n  const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\n\n  useEffect(() => {\n    turnCameraOn(videoRef.current!)\n      .then(() => { setIsCameraOn(true) })\n      .catch(() => { setIsCameraOn(false) })\n  }, []);\n\n  const onnegotiationneeded = useCallback(() => {\n    peerConnectionRef.current?.createOffer()\n      .then(offer => peerConnectionRef.current?.setLocalDescription(offer))\n      .then(() => {\n        sendToWSS(socketRef.current, {\n          type: EWebRTCTypes.VIDEO_OFFER,\n          payload: peerConnectionRef.current?.localDescription,\n        });\n      })\n  }, []);\n\n  const onicecandidate = useCallback((event: RTCPeerConnectionIceEvent) => {\n    if (event.candidate) {\n      sendToWSS(socketRef.current, {\n        type: EWebRTCTypes.NEW_ICE_CANDIDATE,\n        payload: event.candidate\n      });\n    }\n  }, []);\n\n  const ontrack = useCallback((event: RTCTrackEvent) => {\n    receivedVideoRef.current!.srcObject = event.streams[0];\n    sendToWSS(socketRef.current, { type: EClientTypes.CONNECTED });\n    setIsConnected(true);\n  }, []);\n\n  const peerConnectionHandlers = useMemo(() => (\n    { onnegotiationneeded, onicecandidate, ontrack }\n  ), [onicecandidate, onnegotiationneeded, ontrack]);\n\n  const onMessage = useCallback((event: MessageEvent) => {\n    const parsedData: ISendData = JSON.parse(event.data);\n    console.log(parsedData);\n\n    switch (parsedData.type) {\n      case EServerTypes.INFO:\n        setInfo(`Пользователей: ${parsedData.payload.users} (в ожидании: ${parsedData.payload.readyUsers}, на связи: ${parsedData.payload.connectedUsers})`);\n        break;\n\n      case EServerTypes.CALL:\n        initRTC(videoRef.current!, peerConnectionHandlers)\n          .then(pc => peerConnectionRef.current = pc ? pc : null);\n        break;\n\n      case EServerTypes.HANG_UP:\n        receivedVideoRef.current!.srcObject = null;\n        setIsConnected(false);\n        break;\n\n      case EWebRTCTypes.VIDEO_OFFER:\n        handleVideoOfferMsg(videoRef.current!, socketRef.current!, parsedData.payload, peerConnectionHandlers)\n          .then(pc => peerConnectionRef.current = pc ? pc : null);\n        break;\n\n      case EWebRTCTypes.VIDEO_ANSWER:\n        handleVideoAnswerMsg(peerConnectionRef.current!, parsedData.payload);\n        break;\n\n      case EWebRTCTypes.NEW_ICE_CANDIDATE:\n        handleNewICECandidateMsg(parsedData.payload, peerConnectionRef.current!);\n        break;\n    }\n  }, [peerConnectionHandlers]);\n\n  const socketHandlers = useMemo(() => ({ onMessage }), [onMessage]);\n  socketRef.current = useSocket(socketHandlers)[0];\n\n  const handleReadyClick = useCallback(() => {\n    if (isReady) {\n      sendToWSS(socketRef.current, { type: EClientTypes.NOT_READY });\n      setIsReady(false);\n    } else {\n      sendToWSS(socketRef.current, { type: EClientTypes.READY });\n      setIsReady(true);\n    }\n  }, [isReady]);\n\n  const handleNextClick = useCallback(() => {\n    receivedVideoRef.current!.srcObject = null;\n    sendToWSS(socketRef.current, { type: EClientTypes.NOT_CONNECTED });\n    setIsConnected(false);\n  }, []);\n\n  return (\n    <div className=\"app\">\n      <div className=\"app__column\">\n        <div className=\"video\">\n          <div className=\"video__info\">{info}</div>\n\n          <video className=\"video__player\" muted autoPlay playsInline ref={videoRef}>\n            Видео не поддерживается браузером\n              </video>\n        </div>\n      </div>\n\n      <div className=\"app__column\">\n        <div className=\"video\">\n          <video className=\"video__player\" autoPlay playsInline ref={receivedVideoRef}>\n            Видео не поддерживается браузером\n              </video>\n\n          {!isReady && (\n            <button className=\"video__ready\" onClick={handleReadyClick}>\n              <div className=\"video__ready-text\">Начать</div>\n            </button>\n          )}\n\n          {isConnected && (\n            <button className=\"video__next\" onClick={handleNextClick}>Следующий</button>\n          )}\n\n          {isReady && !isConnected && (\n            <span className=\"video__spinner\"></span>\n          )}\n        </div>\n      </div>\n\n      {!isCameraOn && (\n        <h1 className=\"app__warning\">Необходимо дать доступ к камере чтобы участвовать</h1>\n      )}\n    </div>\n  )\n}\n\nexport default App;\n","import { useEffect, useRef } from \"react\";\nimport { ICE_SERVERS, WEB_SOCKET_SERVER } from \"./App.const\";\nimport { ISocketHandlers, IPeerConnectionHandlers } from \"./App.types\";\n\nexport function useSocket(socketHandlers: ISocketHandlers) {\n  const { onMessage } = socketHandlers;\n  const socketRef = useRef<WebSocket | null>(null);\n\n  useEffect(() => {\n    socketRef.current = new WebSocket(WEB_SOCKET_SERVER);\n    socketRef.current.onmessage = onMessage;\n  }, [onMessage]);\n\n  return [socketRef.current];\n}\n\nexport function usePeerConnection(peerConnectionHandlers: IPeerConnectionHandlers) {\n  const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\n\n  useEffect(() => {\n    peerConnectionRef.current = new RTCPeerConnection({ iceServers: ICE_SERVERS });\n    peerConnectionRef.current = { ...peerConnectionRef.current, ...peerConnectionHandlers }\n\n    // peerConnectionRef.current.onicecandidate = handleICECandidateEvent;\n    // peerConnectionRef.current.ontrack = handleTrackEvent;\n    // peerConnectionRef.current.onnegotiationneeded = handleNegotiationNeededEvent;\n    // peerConnectionRef.current.onremovetrack = handleRemoveTrackEvent;\n    // peerConnectionRef.current.oniceconnectionstatechange = handleICEConnectionStateChangeEvent;\n    // peerConnectionRef.current.onicegatheringstatechange = handleICEGatheringStateChangeEvent;\n    // peerConnectionRef.current.onsignalingstatechange = handleSignalingStateChangeEvent;\n  }, [peerConnectionHandlers]);\n\n  return [peerConnectionRef.current];\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App/App';\nimport * as serviceWorker from './serviceWorker';\nimport 'webrtc-adapter';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}