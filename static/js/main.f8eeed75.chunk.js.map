{"version":3,"sources":["components/App/App.hooks.ts","components/App/App.helpers.ts","components/App/App.tsx","serviceWorker.ts","index.tsx"],"names":["ESendTypes","videoElement","a","navigator","mediaDevices","getUserMedia","audio","video","stream","srcObject","isMediaStream","undefined","getTracks","App","useState","isReady","setIsReady","readyUsersNumber","setReadyUsersNumber","videoRef","useRef","receivedVideoRef","socketRef","peerConnectionRef","useEffect","turnCameraOn","current","onMessage","useCallback","event","parsedData","JSON","parse","data","console","log","type","READY_USERS_NUMBER","payload","VIDEO_OFFER","peerConnection","socket","sdp","desc","RTCSessionDescription","setRemoteDescription","then","forEach","track","addTrack","createAnswer","answer","setLocalDescription","send","stringify","VIDEO_ANSWER","localDescription","handleVideoOfferMsg","handleVideoAnswerMsg","NEW_ICE_CANDIDATE","candidateInit","candidate","RTCIceCandidate","addIceCandidate","handleNewICECandidateMsg","handleNegotiationNeededEvent","createOffer","offer","handleICECandidateEvent","handleTrackEvent","streams","socketHandlers","useMemo","peerConnectionHandlers","handleReadyClick","USER_IS_NOT_READY","USER_IS_READY","Number","invite","WebSocket","onmessage","useSocket","RTCPeerConnection","iceServers","urls","username","credential","onicecandidate","ontrack","onnegotiationneeded","usePeerConnection","className","muted","autoPlay","playsInline","ref","onClick","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.f8eeed75.chunk.js","sourcesContent":["import { useEffect, useRef } from \"react\";\n\nexport enum ESendTypes {\n  USER_IS_READY = 'user_is_ready',\n  USER_IS_NOT_READY = 'user_is_not_ready',\n  READY_USERS_NUMBER = 'ready_users_number',\n  NEXT = 'next',\n  NEW_ICE_CANDIDATE = 'new_ice_candidate',\n  VIDEO_OFFER = 'video_offer',\n  VIDEO_ANSWER = 'video_answer',\n}\n\nexport interface ISendData<T = any> {\n  type: ESendTypes;\n  payload?: T;\n}\n\ninterface ISocketHandlers {\n  onMessage: (event: MessageEvent) => void;\n}\n\nexport function useSocket(socketHandlers: ISocketHandlers) {\n  const { onMessage } = socketHandlers;\n  const socketRef = useRef<WebSocket | null>(null);\n\n  useEffect(() => {\n    socketRef.current = new WebSocket('wss://evstar.ru:7000');\n    // socketRef.current = new WebSocket('ws://localhost:8080');\n    socketRef.current.onmessage = onMessage;\n  }, [onMessage]);\n\n  return [socketRef.current];\n}\n\ninterface IPeerConnectionHandlers {\n  handleNegotiationNeededEvent: () => void;\n  handleICECandidateEvent: (event: RTCPeerConnectionIceEvent) => void;\n  handleTrackEvent: (event: RTCTrackEvent) => void;\n}\n\nexport function usePeerConnection(peerConnectionHandlers: IPeerConnectionHandlers) {\n  const { handleNegotiationNeededEvent, handleICECandidateEvent, handleTrackEvent } = peerConnectionHandlers;\n  const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\n\n  useEffect(() => {\n    peerConnectionRef.current = new RTCPeerConnection({\n      iceServers: [     // Information about ICE servers - Use your own!\n        {\n          urls: ['stun:stun.evstar.ru:5349', 'turn:turn.evstar.ru:5349'],\n          username: 'evstarostin',\n          credential: 'jck30011989',\n        }\n      ]\n    });\n\n    peerConnectionRef.current.onicecandidate = handleICECandidateEvent;\n    peerConnectionRef.current.ontrack = handleTrackEvent;\n    peerConnectionRef.current.onnegotiationneeded = handleNegotiationNeededEvent;\n    // peerConnectionRef.current.onremovetrack = handleRemoveTrackEvent;\n    // peerConnectionRef.current.oniceconnectionstatechange = handleICEConnectionStateChangeEvent;\n    // peerConnectionRef.current.onicegatheringstatechange = handleICEGatheringStateChangeEvent;\n    // peerConnectionRef.current.onsignalingstatechange = handleSignalingStateChangeEvent;\n  }, [handleICECandidateEvent, handleNegotiationNeededEvent, handleTrackEvent]);\n\n  return [peerConnectionRef.current];\n}","import { ESendTypes } from \"./App.hooks\";\n\nexport async function turnCameraOn(videoElement: HTMLVideoElement) {\n  const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });\n\n  videoElement.srcObject = stream;\n}\n\nexport function turnCameraOff(videoElement: HTMLVideoElement) {\n  const { srcObject } = videoElement;\n  const mediaStreamTracks: MediaStreamTrack[] = isMediaStream(srcObject) ? srcObject.getTracks() : [];\n\n  mediaStreamTracks.forEach(track => track.stop());\n  videoElement.srcObject = null;\n}\n\nexport function invite(peerConnection: RTCPeerConnection, videoElement: HTMLVideoElement) {\n  const { srcObject } = videoElement;\n\n  if (isMediaStream(srcObject)) {\n    const mediaStreamTracks: MediaStreamTrack[] = srcObject.getTracks();\n    mediaStreamTracks.forEach(track => peerConnection.addTrack(track, srcObject));\n  }\n}\n\nexport function handleNewICECandidateMsg(candidateInit: RTCIceCandidateInit, peerConnection: RTCPeerConnection) {\n  const candidate = new RTCIceCandidate(candidateInit);\n\n  peerConnection.addIceCandidate(candidate);\n}\n\nexport function handleVideoOfferMsg(\n  peerConnection: RTCPeerConnection,\n  videoElement: HTMLVideoElement,\n  socket: WebSocket,\n  sdp: RTCSessionDescriptionInit,\n) {\n  console.log('sdp - handleVideoOfferMsg', sdp);\n\n  const { srcObject } = videoElement;\n  const desc = new RTCSessionDescription(sdp);\n\n  peerConnection.setRemoteDescription(desc)\n    .then(() => {\n      if (isMediaStream(srcObject)) {\n        srcObject.getTracks().forEach(track => peerConnection.addTrack(track, srcObject));\n      }\n    })\n    .then(() => peerConnection.createAnswer())\n    .then((answer) => peerConnection.setLocalDescription(answer))\n    .then(() => {\n      socket.send(JSON.stringify({\n        type: ESendTypes.VIDEO_ANSWER,\n        payload: peerConnection.localDescription\n      }));\n    })\n}\n\nexport function handleVideoAnswerMsg(peerConnection: RTCPeerConnection, sdp: RTCSessionDescriptionInit) {\n  console.log('sdp - handleVideoAnswerMsg', sdp);\n\n  const desc = new RTCSessionDescription(sdp);\n\n  peerConnection.setRemoteDescription(desc);\n}\n\nexport function isMediaStream(srcObject: MediaStream | MediaSource | Blob | null): srcObject is MediaStream {\n  return (srcObject as MediaStream).getTracks !== undefined;\n}","import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { handleNewICECandidateMsg, handleVideoAnswerMsg, handleVideoOfferMsg, invite, turnCameraOff, turnCameraOn } from './App.helpers';\nimport { ESendTypes, ISendData, usePeerConnection, useSocket } from './App.hooks';\nimport './App.scss';\n\nfunction App() {\n  const [isReady, setIsReady] = useState(false);\n  const [readyUsersNumber, setReadyUsersNumber] = useState<number | null>(null);\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const receivedVideoRef = useRef<HTMLVideoElement>(null);\n  const socketRef = useRef<WebSocket | null>(null);\n  const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\n\n  useEffect(() => {\n    turnCameraOn(videoRef.current!);\n  }, []);\n\n  const onMessage = useCallback((event: MessageEvent) => {\n    const parsedData: ISendData = JSON.parse(event.data);\n    console.log(parsedData);\n\n    switch (parsedData.type) {\n      case ESendTypes.READY_USERS_NUMBER:\n        setReadyUsersNumber(parsedData.payload);\n        break;\n\n      case ESendTypes.VIDEO_OFFER:\n        handleVideoOfferMsg(peerConnectionRef.current!, videoRef.current!, socketRef.current!, parsedData.payload);\n        break;\n\n      case ESendTypes.VIDEO_ANSWER:\n        console.log('parsedData.payload', parsedData.payload);\n        handleVideoAnswerMsg(peerConnectionRef.current!, parsedData.payload);\n        break;\n\n      case ESendTypes.NEW_ICE_CANDIDATE:\n        handleNewICECandidateMsg(parsedData.payload, peerConnectionRef.current!);\n        break;\n    }\n  }, []);\n\n  const handleNegotiationNeededEvent = useCallback(() => {\n    peerConnectionRef.current?.createOffer().then((offer) => peerConnectionRef.current?.setLocalDescription(offer))\n      .then(() => {\n        socketRef.current?.send(JSON.stringify({\n          type: ESendTypes.VIDEO_OFFER,\n          payload: peerConnectionRef.current?.localDescription,\n        }));\n      })\n  }, []);\n\n  const handleICECandidateEvent = useCallback((event: RTCPeerConnectionIceEvent) => {\n    if (event.candidate) {\n      socketRef.current?.send(JSON.stringify({\n        type: ESendTypes.NEW_ICE_CANDIDATE,\n        payload: event.candidate\n      }));\n    }\n  }, []);\n\n  const handleTrackEvent = useCallback((event: RTCTrackEvent) => {\n    receivedVideoRef.current!.srcObject = event.streams[0];\n  }, []);\n\n  const socketHandlers = useMemo(() => ({\n    onMessage,\n  }), [onMessage]);\n\n  const peerConnectionHandlers = useMemo(() => ({\n    handleNegotiationNeededEvent,\n    handleICECandidateEvent,\n    handleTrackEvent,\n  }), [handleICECandidateEvent, handleNegotiationNeededEvent, handleTrackEvent]);\n\n  const handleReadyClick = useCallback(() => {\n    const { current: socket } = socketRef;\n\n    if (isReady) {\n      socket?.send(JSON.stringify({ type: ESendTypes.USER_IS_NOT_READY }));\n      setIsReady(false);\n    } else {\n      socket?.send(JSON.stringify({ type: ESendTypes.USER_IS_READY }));\n      setIsReady(true);\n\n      if (Number(readyUsersNumber) > 0) {\n        invite(peerConnectionRef.current!, videoRef.current!);\n      }\n    }\n  }, [isReady, readyUsersNumber]);\n\n  socketRef.current = useSocket(socketHandlers)[0];\n  peerConnectionRef.current = usePeerConnection(peerConnectionHandlers)[0];\n\n  return (\n    <div className=\"app\">\n      <div className=\"app__column\">\n        <div className=\"video\">\n          <div className=\"video__attendance\">\n            Пользователей в очереди: {readyUsersNumber}\n          </div>\n\n          <video className=\"video__player\" muted autoPlay playsInline ref={videoRef}>\n            Видео не поддерживается браузером\n          </video>\n        </div>\n      </div>\n\n      <div className=\"app__column\">\n        <div className=\"video\">\n          <video className=\"video__player\" autoPlay playsInline ref={receivedVideoRef}>\n            Видео не поддерживается браузером\n          </video>\n\n          <div className=\"video__footer\">\n            <button className=\"video__ready\" onClick={handleReadyClick}>\n              {isReady ? 'Закончить' : 'Начать'}\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App/App';\nimport * as serviceWorker from './serviceWorker';\nimport 'webrtc-adapter';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}