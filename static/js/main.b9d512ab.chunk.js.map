{"version":3,"sources":["components/App/App.types.ts","components/App/App.const.ts","components/App/App.helpers.ts","components/App/App.tsx","components/App/App.hooks.ts","serviceWorker.ts","index.tsx"],"names":["EWebRTCTypes","EClientTypes","EServerTypes","ICE_SERVERS","urls","username","credential","videoElement","a","stream","navigator","mediaDevices","getUserMedia","audio","video","srcObject","Promise","resolve","reject","peerConnectionHandlers","peerConnection","createPeerConnection","isMediaStream","getTracks","forEach","track","addTrack","socket","sdp","desc","RTCSessionDescription","setRemoteDescription","createAnswer","answer","setLocalDescription","send","JSON","stringify","type","VIDEO_ANSWER","payload","localDescription","undefined","sendToWSS","json","RTCPeerConnection","iceServers","Object","assign","App","useState","isJoinedToWSS","setIsJoinedToWSS","isCameraOn","setIsCameraOn","isReady","setIsReady","isConnected","setIsConnected","info","setInfo","videoRef","useRef","receivedVideoRef","socketRef","peerConnectionRef","useEffect","turnCameraOn","current","then","catch","closePeerConnection","useCallback","close","onnegotiationneeded","createOffer","offer","VIDEO_OFFER","onicecandidate","event","candidate","NEW_ICE_CANDIDATE","ontrack","streams","CONNECTED","useMemo","onMessage","parsedData","parse","data","console","log","INFO","users","readyUsers","connectedUsers","CALL","initRTC","pc","HANG_UP","handleVideoOfferMsg","handleVideoAnswerMsg","candidateInit","RTCIceCandidate","addIceCandidate","error","handleNewICECandidateMsg","onOpen","socketHandlers","WebSocket","onmessage","onopen","useSocket","handleReadyClick","NOT_READY","READY","handleNextClick","NOT_CONNECTED","className","muted","autoPlay","playsInline","ref","onClick","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","registration","unregister","message"],"mappings":"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","file":"static/js/main.b9d512ab.chunk.js","sourcesContent":["export enum EWebRTCTypes {\n  NEW_ICE_CANDIDATE = '[webrtc]: new_ice_candidate',\n  VIDEO_OFFER = '[webrtc]: video_offer',\n  VIDEO_ANSWER = '[webrtc]: video_answer',\n}\n\nexport enum EClientTypes {\n  READY = '[client]: ready',\n  NOT_READY = '[client]: not_ready',\n  CONNECTED = '[client]: connected',\n  NOT_CONNECTED = '[client]: not_connected',\n}\n\nexport enum EServerTypes {\n  INFO = '[server]: info',\n  CALL = '[server]: call',\n  HANG_UP = '[server]: hang_up',\n}\n\nexport interface ISendData<T = any> {\n  type: EWebRTCTypes | EClientTypes | EServerTypes;\n  payload?: T;\n}\n\nexport interface ISocketHandlers {\n  onMessage: (event: MessageEvent) => void;\n  onOpen: (event: Event) => void;\n}\n\nexport interface IPeerConnectionHandlers {\n  onnegotiationneeded: () => void;\n  onicecandidate: (event: RTCPeerConnectionIceEvent) => void;\n  ontrack: (event: RTCTrackEvent) => void;\n}","export const ICE_SERVERS = [\n  {\n    urls: 'stun:evstar.ru:3478',\n    username: 'evstarostin',\n    credential: 'jck30011989',\n  },\n  {\n    urls: 'turn:evstar.ru:3478',\n    username: 'evstarostin',\n    credential: 'jck30011989',\n  },\n]\n\nexport const WEB_SOCKET_SERVER = process.env.NODE_ENV === 'development' ? 'ws://localhost:7000' : 'wss://evstar.ru:7000';","import { ICE_SERVERS } from \"./App.const\";\nimport { EWebRTCTypes, IPeerConnectionHandlers, ISendData } from \"./App.types\";\n\nexport async function turnCameraOn(videoElement: HTMLVideoElement) {\n  let stream = null;\n\n  try {\n    stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });\n    videoElement.srcObject = stream;\n    return Promise.resolve();\n  } catch(error) {\n    return Promise.reject(error);\n  }\n}\n\nexport async function initRTC(\n  videoElement: HTMLVideoElement,\n  peerConnectionHandlers: IPeerConnectionHandlers,\n) {\n  const { srcObject } = videoElement;\n  const peerConnection = createPeerConnection(peerConnectionHandlers);\n\n  if (!isMediaStream(srcObject)) return;\n\n  try {\n    await srcObject.getTracks().forEach(track => peerConnection.addTrack(track, srcObject));\n    return Promise.resolve(peerConnection);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n}\n\nexport function handleNewICECandidateMsg(candidateInit: RTCIceCandidateInit, peerConnection: RTCPeerConnection) {\n  const candidate = new RTCIceCandidate(candidateInit);\n\n  try {\n    peerConnection.addIceCandidate(candidate);\n  } catch (error) {}\n}\n\nexport async function handleVideoOfferMsg(\n  videoElement: HTMLVideoElement,\n  socket: WebSocket,\n  sdp: RTCSessionDescriptionInit,\n  peerConnectionHandlers: IPeerConnectionHandlers,\n) {\n  const { srcObject } = videoElement;\n  if (!isMediaStream(srcObject)) return;\n  \n  try {\n    const peerConnection = createPeerConnection(peerConnectionHandlers);\n    const desc = new RTCSessionDescription(sdp);\n    await peerConnection.setRemoteDescription(desc);\n    srcObject.getTracks().forEach(track => peerConnection.addTrack(track, srcObject));\n    const answer = await peerConnection.createAnswer();\n    await peerConnection.setLocalDescription(answer);\n    socket.send(JSON.stringify({ type: EWebRTCTypes.VIDEO_ANSWER, payload: peerConnection.localDescription }));\n    return Promise.resolve(peerConnection);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n}\n\nexport function handleVideoAnswerMsg(peerConnection: RTCPeerConnection, sdp: RTCSessionDescriptionInit) {\n  const desc = new RTCSessionDescription(sdp);\n\n  peerConnection.setRemoteDescription(desc);\n}\n\nexport function isMediaStream(srcObject: MediaStream | MediaSource | Blob | null): srcObject is MediaStream {\n  return (srcObject as MediaStream).getTracks !== undefined;\n}\n\nexport function sendToWSS(socket: WebSocket | null, json: ISendData) {\n  socket?.send(JSON.stringify(json));\n}\n\nfunction createPeerConnection(peerConnectionHandlers: IPeerConnectionHandlers) {\n  const peerConnection = new RTCPeerConnection({ iceServers: ICE_SERVERS });\n\n  Object.assign(peerConnection, peerConnectionHandlers);\n  return peerConnection;\n}","import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport {\n  handleNewICECandidateMsg,\n  handleVideoAnswerMsg,\n  handleVideoOfferMsg,\n  initRTC,\n  turnCameraOn,\n  sendToWSS,\n} from './App.helpers';\nimport { useSocket } from './App.hooks';\nimport { EClientTypes, EServerTypes, EWebRTCTypes, ISendData } from './App.types';\nimport './App.scss';\n\nfunction App() {\n  const [isJoinedToWSS, setIsJoinedToWSS] = useState(false);\n  const [isCameraOn, setIsCameraOn] = useState(false);\n  const [isReady, setIsReady] = useState(false);\n  const [isConnected, setIsConnected] = useState(false);\n  const [info, setInfo] = useState('Подключение к серверу ...');\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const receivedVideoRef = useRef<HTMLVideoElement>(null);\n  const socketRef = useRef<WebSocket | null>(null);\n  const peerConnectionRef = useRef<RTCPeerConnection | null>(null);\n\n  useEffect(() => {\n    turnCameraOn(videoRef.current!)\n      .then(() => { setIsCameraOn(true) })\n      .catch(() => { setIsCameraOn(false) })\n  }, []);\n\n  const closePeerConnection = useCallback(() => {\n    peerConnectionRef.current?.close();\n    peerConnectionRef.current = null;\n    receivedVideoRef.current!.srcObject = null;\n  }, []);\n\n  const onnegotiationneeded = useCallback(() => {\n    peerConnectionRef.current?.createOffer()\n      .then(offer => peerConnectionRef.current?.setLocalDescription(offer))\n      .then(() => {\n        sendToWSS(socketRef.current, {\n          type: EWebRTCTypes.VIDEO_OFFER,\n          payload: peerConnectionRef.current?.localDescription,\n        });\n      })\n  }, []);\n\n  const onicecandidate = useCallback((event: RTCPeerConnectionIceEvent) => {\n    if (event.candidate) {\n      sendToWSS(socketRef.current, {\n        type: EWebRTCTypes.NEW_ICE_CANDIDATE,\n        payload: event.candidate\n      });\n    }\n  }, []);\n\n  const ontrack = useCallback((event: RTCTrackEvent) => {\n    receivedVideoRef.current!.srcObject = event.streams[0];\n    sendToWSS(socketRef.current, { type: EClientTypes.CONNECTED });\n    setIsConnected(true);\n  }, []);\n\n  const peerConnectionHandlers = useMemo(() => (\n    { onnegotiationneeded, onicecandidate, ontrack }\n  ), [onicecandidate, onnegotiationneeded, ontrack]);\n\n  const onMessage = useCallback((event: MessageEvent) => {\n    const parsedData: ISendData = JSON.parse(event.data);\n    console.log(parsedData);\n\n    switch (parsedData.type) {\n      case EServerTypes.INFO:\n        setInfo(`Пользователей: ${parsedData.payload.users} (в ожидании: ${parsedData.payload.readyUsers}, на связи: ${parsedData.payload.connectedUsers})`);\n        break;\n\n      case EServerTypes.CALL:\n        initRTC(videoRef.current!, peerConnectionHandlers)\n          .then(pc => peerConnectionRef.current = pc ? pc : null);\n        break;\n\n      case EServerTypes.HANG_UP:\n        closePeerConnection();\n        setIsConnected(false);\n        break;\n\n      case EWebRTCTypes.VIDEO_OFFER:\n        handleVideoOfferMsg(videoRef.current!, socketRef.current!, parsedData.payload, peerConnectionHandlers)\n          .then(pc => peerConnectionRef.current = pc ? pc : null);\n        break;\n\n      case EWebRTCTypes.VIDEO_ANSWER:\n        handleVideoAnswerMsg(peerConnectionRef.current!, parsedData.payload);\n        break;\n\n      case EWebRTCTypes.NEW_ICE_CANDIDATE:\n        handleNewICECandidateMsg(parsedData.payload, peerConnectionRef.current!);\n        break;\n    }\n  }, [closePeerConnection, peerConnectionHandlers]);\n\n  const onOpen = useCallback((event: Event) => {\n    setIsJoinedToWSS(true);\n  }, []);\n\n  const socketHandlers = useMemo(() => ({ onMessage, onOpen }), [onMessage, onOpen]);\n  socketRef.current = useSocket(socketHandlers)[0];\n\n  const handleReadyClick = useCallback(() => {\n    if (isReady) {\n      sendToWSS(socketRef.current, { type: EClientTypes.NOT_READY });\n      setIsReady(false);\n    } else {\n      sendToWSS(socketRef.current, { type: EClientTypes.READY });\n      setIsReady(true);\n    }\n  }, [isReady]);\n\n  const handleNextClick = useCallback(() => {\n    closePeerConnection();\n    sendToWSS(socketRef.current, { type: EClientTypes.NOT_CONNECTED });\n    setIsConnected(false);\n  }, [closePeerConnection]);\n\n  return (\n    <div className=\"app\">\n      <div className=\"app__column\">\n        <div className=\"video\">\n          <div className=\"video__info\">{info}</div>\n\n          <video className=\"video__player\" muted autoPlay playsInline ref={videoRef}>\n            Видео не поддерживается браузером\n          </video>\n        </div>\n      </div>\n\n      <div className=\"app__column\">\n        <div className=\"video\">\n          <video className=\"video__player\" autoPlay playsInline ref={receivedVideoRef}>\n            Видео не поддерживается браузером\n          </video>\n\n          {!isReady && isJoinedToWSS && (\n            <button className=\"video__ready\" onClick={handleReadyClick}>\n              <div className=\"video__ready-text\">Начать</div>\n            </button>\n          )}\n\n          {isConnected && (\n            <button className=\"video__next\" onClick={handleNextClick}>Следующий</button>\n          )}\n\n          {isReady && !isConnected && (\n            <span className=\"video__spinner\"></span>\n          )}\n        </div>\n      </div>\n\n      {!isCameraOn && (\n        <h1 className=\"app__warning\">Необходимо дать доступ к камере чтобы участвовать</h1>\n      )}\n    </div>\n  )\n}\n\nexport default App;\n","import { useEffect, useRef } from \"react\";\nimport { WEB_SOCKET_SERVER } from \"./App.const\";\nimport { ISocketHandlers } from \"./App.types\";\n\nexport function useSocket(socketHandlers: ISocketHandlers) {\n  const { onMessage, onOpen } = socketHandlers;\n  const socketRef = useRef<WebSocket | null>(null);\n\n  useEffect(() => {\n    socketRef.current = new WebSocket(WEB_SOCKET_SERVER);\n    socketRef.current.onmessage = onMessage;\n    socketRef.current.onopen = onOpen;\n  }, [onMessage, onOpen]);\n\n  return [socketRef.current];\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App/App';\nimport * as serviceWorker from './serviceWorker';\nimport 'webrtc-adapter';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}